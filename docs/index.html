<!DOCTYPE html>
<html lang="en">
<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OBM</title>
    <link
            rel="icon"
            href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>♻️</text></svg>"
    />

</head>
<body>
<input type="radio" name="mobile_show" value="source" id="showSource" checked>
<input type="radio" name="mobile_show" value="result" id="showResult">
<nav>

    <label for="showSource">
        Source
    </label>
    <label for="showResult">
        Result
    </label>

</nav>
<textarea id="source"># Our beautiful mess (obm)

This is a markdown to markdown converter. That sounds a bit silly, I know.
All it does is look for lines that have an arrow in them, and consider them
as an instruction, like below :

    A->B

What we just did is declare a link from A to B. OBM will replace it by a small
chart, rendered in text in a Markdown code block (indented with 4 blocks).

The result would look something like this (head to https://obm.lecaro.me/ to
see an interactive side by side view)

    ┏━━━┓    ┏━━━┓
    ┃ A ┃━━━━┃ B ┃
    ┗━━━┛    ┗━━━┛

You can then add a second link to your document, and it will be added to the
same chart as before.

    B->C

You can declare more than one link per line too, by chaining arrows.

    C->D->E->A

If you want, you can cluster nodes by using the colon symbol between a parent
and child, like this:

    Parent:First child -> Parent:Other child

## How does it work ?

Since the beginning, we've been adding nodes and links to the same graph, it's
just that the resulting nodes are introduced one by one. The nodes that have
already been introduced are kept.

The rendering of the graphs is powered by a small engine I wrote in rust, and
running in a background thread in WASM. It uses a variety of methods to try to
come up with a nice and compact text representation of the chart.

It doesn't handle huge charts very well (30+ nodes) and runs single threaded in
WASM mode. I also have a compiled binary for linux that makes use of all the
threads available to generate large graphs faster.

## Roadmap

- rendering : show arrow heads, keep links direction information
- rendering : grow names rectangles to fit grid
- mutation : isolate a subset of the graph linked together, optimize it, then bring it back in
- mutation : isolate parent and its children, optimize it, then bring it back in
- mutation : move node furthest from center closer
- mutation : draw two rectangles, then swap location of all touching nodes
- mutation : use layout algorithm as mutation
- mutation :  see if there are interesting ideas in https://www.graphviz.org/docs/layouts/
- scoring : make links to self or parent look nicer
- scoring : add symmetry rules (tricky to do well)
- syntax: only consider lines indented with 4 blocks at least
- syntax: fix a node to a specific location
- syntax: split a document into chunks and start a new chart for each group
- cli use : improve one world per thread, then merge and do selection/birth every N seconds
- cli use : progress bar and intermediate results rendering to stdout
- cli use : editor mode lets you modify the graph and fix the nodes location
- wasm : allow multithreaded rendering
- output : generate svg instead of text diagram
- output : generate slides with presenter notes
 
 
 </textarea>
<pre id="result">
Generating...
    <noscript>Please turn on javascript</noscript>
</pre>
<style>
    * {
        box-sizing: border-box;
    }

    input[type="radio"] {
        position: absolute;
        left: -1000px;
    }

    @media screen and (min-width: 1000px) {

        body {
            padding: 0;
            margin: 0;
            display: flex;
            align-items: stretch;
            height: 100vh;
        }

        nav {
            display: none;
        }

        #source {
            padding: 20px;
            flex-grow: 0;
            flex-shrink: 0;
            border: none;
            overflow: auto;
            resize: horizontal;
            font-family: monospace;
            white-space: pre;
        }

        #result {
            flex-grow: 1;
            flex-shrink: 1;
            border-left: 1px solid black;
            position: relative;
            font-family: monospace;
            overflow: auto;
            padding: 20px;
        }
    }

    @media screen and (max-width: 1000px) {

        body {
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            height: 100vh;
        }

        nav {
            background: #333;
            color: #FFF;
            font-family: monospace;
        }

        nav > label {
            display: inline-block;
            padding: 0 20px;

            line-height: 40px;

        }

        input#showSource:checked ~ #result,
        input#showResult:checked ~ #source {
            display: none;
        }

        input#showSource:checked ~ nav > label[for="showSource"],
        input#showResult:checked ~ nav > label[for="showResult"] {
            background: white;
            color: #000;
        }


        #source, #result {
            padding: 20px;
            width: 100vw !important;

            flex-grow: 1;
            display: block;
            align-self: stretch;
            resize: none;
            border: none;
            overflow: auto;
        }
    }
</style>

<script>
    // Selectors
    let result = document.getElementById('result');
    let source = document.getElementById('source');

    // Save textarea width
    source.style.width = (localStorage.getItem("ta-size") || (window.innerWidth / 2)) + "px";
    new ResizeObserver(() => localStorage.setItem("ta-size", source.scrollWidth.toString())).observe(source);

    // Send work to worker and update preview
    const myWorker = new Worker("worker.js", {type: "module"});
    let version = 0;
    let timeout = 0;

    function regenerate() {
        result.style.opacity = 0.5;
        version++
        clearTimeout(timeout);
        timeout = setTimeout(() => myWorker.postMessage({version, source: source.value}), 300)
    }

    source.addEventListener('keyup', regenerate)
    source.addEventListener('change', regenerate)
    regenerate()
    myWorker.onmessage = e => {
        if (e.data.version === version) {
            result.textContent = e.data.output
            result.style.opacity = 1;
        }
    }

    //     Add tab support
    function supportTabIndentation(textarea) {
        const offsetToLineAndOffset = (lines, offset) => {
            let line = 0
            while (offset > lines[line].length && line < lines.length - 1) {
                offset = offset - lines[line].length - 1
                line++
            }
            return {line, offset}
        }
        const LineAndOffsetToOffset = (lines, line, offset) => {
            for (let i = 0; i < line; i++)
                offset += lines[i].length + 1

            return offset
        }

        textarea.addEventListener('keydown', e => {
            if (e.key == 'Tab') {
                e.preventDefault()
                const lines = e.target.value.split('\n')

                const selection = [offsetToLineAndOffset(lines, textarea.selectionStart),
                    offsetToLineAndOffset(lines, textarea.selectionEnd)]
                for (var l = selection[0].line; l <= selection[1].line; l++) {
                    const originalLength = lines[l].length
                    if (e.shiftKey) {
                        lines[l] = lines[l].replace(/^ {0,4}/, '')
                    } else {
                        lines[l] = '    ' + lines[l]
                    }
                    // How much the line moved
                    const delta = lines[l].length - originalLength
                    // Update the user selection if it's on this line
                    selection.forEach((sel) => {
                        if (sel.line == l) {
                            sel.offset = Math.max(0, sel.offset + delta)
                        }
                    })
                }
                textarea.value = lines.join('\n')
                textarea.selectionStart = LineAndOffsetToOffset(lines, selection[0].line, selection[0].offset)
                textarea.selectionEnd = LineAndOffsetToOffset(lines, selection[1].line, selection[1].offset)
            }
            if (e.key === 'Enter') {
                const {selectionStart, selectionEnd, value} = textarea

                const linesBeforeCursor = value.slice(0, selectionStart).split('\n')
                const lastLine = linesBeforeCursor[linesBeforeCursor.length - 1]
                const indentation = lastLine.match(/^\s+/)?.[0] || ''

                textarea.value = value.slice(0, selectionStart) + '\n' + indentation + value.slice(selectionEnd)
                textarea.selectionStart = selectionStart + 1 + indentation.length
                textarea.selectionEnd = textarea.selectionStart

                e.preventDefault()
            }
        })
    }

    supportTabIndentation(source)

    // Disable ctrl S
    document.addEventListener("keydown", event => {
        if (event.key == 's' && event.ctrlKey) {
            event.preventDefault()
        }
    })
</script>
</body>
</html>